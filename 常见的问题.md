## python 里面深拷贝和浅拷贝的区别，以及实现方法

### 1. 浅拷贝
**特点**：
-    **只复制最外层对象**，嵌套对象仍然是**原对象的引用**（修改嵌套对象会影响原对象）  
-   适用于**简单数据结构**（如单层列表、字典）

#### **实现方法**
#### **1.1  使用 `copy()` 方法**

```python
import copy

original = [1, 2, [3, 4]]
shallow_copy = original.copy()  # 或 copy.copy(original)

# 修改浅拷贝的嵌套对象会影响原对象
shallow_copy[2][0] = 999
print(original)  # [1, 2, [999, 4]]  🚨 原对象被修改！
```
#### **1.2   切片（适用于列表）**

```python
original = [1, 2, [3, 4]]
shallow_copy = original[:]

shallow_copy[2][0] = 999
print(original)  # [1, 2, [999, 4]]  🚨 同样会影响原对象！
```
#### **1.3 `dict.copy()`（适用于字典）**
```python
original = {"a": 1, "b": [2, 3]}
shallow_copy = original.copy()

shallow_copy["b"][0] = 999
print(original)  # {"a": 1, "b": [999, 3]}  🚨 原字典被修改！
```
### 2. 深拷贝
**特点**：
-   **完全独立复制**，包括所有嵌套对象（修改拷贝后的对象不会影响原对象）。
-   适用于**复杂嵌套结构**（如多层列表、字典）。

#### **实现方法**
#### **2.1  使用 `copy.deepcopy()` 方法**

```python
import copy

original = [1, 2, [3, 4]]
deep_copy = copy.deepcopy(original)

# 修改深拷贝的嵌套对象不会影响原对象
deep_copy[2][0] = 999
print(original)  # [1, 2, [3, 4]]  ✅ 原对象不变！
print(deep_copy)  # [1, 2, [999, 4]]
```

### 3. 特殊情况
#### **3.1  不可变对象 ( int, str, tuple )**

浅拷贝和深拷贝**没有区别**，因为它们本身不可变，Python 会直接复用原对象

```python
a = (1, 2, 3)
b = copy.copy(a)      # 仍然是原元组
c = copy.deepcopy(a)  # 仍然是原元组
print(b is a)  # True
print(c is a)  # True
```

## 线程，进程和携程，有什么区别，都用哪些优缺点已经应用场景

## **1. 进程（Process）—— 独立厨房**
-   **定义**：一个独立的程序执行单位，**拥有独立的内存空间**（比如开一家分店）。
-   **优点**：
    -   稳定性高，一个进程崩溃不会影响其他进程（一家店着火，其他店照常营业🔥➡️🏪）。
    -   适合**CPU密集型任务**（比如视频渲染、科学计算）。
-   **缺点**：
    -   创建和切换开销大（开新店要租场地、招人，慢！）。
    -   进程间通信复杂（分店之间打电话得用IPC，比如管道、消息队列）。
-   **应用场景**：
    -   浏览器（每个标签页是一个进程，崩溃了不影响其他页面）。
    -   Python 的多进程计算（`multiprocessing` 库）。


## **2. 线程（Thread）—— 餐厅里的多个服务员**

-   **定义**：**进程内的子任务**，共享同一块内存（一家店里的多个服务员共用同一个厨房）。
-   **优点**：
    -   创建和切换速度快（服务员培训一下就能上岗）。
    -   适合**IO密集型任务**（比如网络请求、文件读写）。
-   **缺点**：
    -   线程间共享数据容易冲突（服务员A和B同时抢最后一份牛排🥩→可能送错桌）。
    -   一个线程崩溃可能导致整个进程崩溃（一个服务员打翻油锅，整个厨房停摆💥）。
-   **应用场景**：
    -   Web服务器（每个用户请求用一个线程处理，如Java的Tomcat）。
    -   GUI程序（主线程更新界面，子线程后台计算）。

## **3. 协程（Coroutine）—— 一个服务员兼职多桌**

-   **定义**：**用户态轻量级线程**，由程序员手动调度（服务员在A桌点完菜，立刻去B桌倒水，不用等厨师）。
-   **优点**：
    -   超高并发（一个线程能跑几万协程，像超级服务员）。
    -   几乎没有切换开销（没有系统调用，纯代码控制）。
-   **缺点**：
    -   需要配合异步IO（如果协程卡在同步IO上，整个线程阻塞）。
    -   调试复杂（“服务员”跳来跳去，日志像侦探小说🕵️‍♂️）。
-   **应用场景**：
    -   高并发网络服务（如Python的`asyncio`、Go的`goroutine`）。
    -   爬虫（同时发几百个请求，但只用几个线程）。
        















<!--stackedit_data:
eyJoaXN0b3J5IjpbNTkyMTkwNTE1LC0yMDg4NzQ2NjEyXX0=
-->