## python 里面深拷贝和浅拷贝的区别，以及实现方法

### 1. 浅拷贝
**特点**：
-    **只复制最外层对象**，嵌套对象仍然是**原对象的引用**（修改嵌套对象会影响原对象）  
-   适用于**简单数据结构**（如单层列表、字典）

#### **实现方法**
#### **1.1  使用 `copy()` 方法**

```python
import copy

original = [1, 2, [3, 4]]
shallow_copy = original.copy()  # 或 copy.copy(original)

# 修改浅拷贝的嵌套对象会影响原对象
shallow_copy[2][0] = 999
print(original)  # [1, 2, [999, 4]]  🚨 原对象被修改！
```
#### **1.2   切片（适用于列表）**

```python
original = [1, 2, [3, 4]]
shallow_copy = original[:]

shallow_copy[2][0] = 999
print(original)  # [1, 2, [999, 4]]  🚨 同样会影响原对象！
```
#### **1.3 `dict.copy()`（适用于字典）**
```python
original = {"a": 1, "b": [2, 3]}
shallow_copy = original.copy()

shallow_copy["b"][0] = 999
print(original)  # {"a": 1, "b": [999, 3]}  🚨 原字典被修改！
```
### 2. 深拷贝
**特点**：
-   **完全独立复制**，包括所有嵌套对象（修改拷贝后的对象不会影响原对象）。
-   适用于**复杂嵌套结构**（如多层列表、字典）。

#### **实现方法**
#### **2.1  使用 `copy.deepcopy()` 方法**

```python
import copy

original = [1, 2, [3, 4]]
deep_copy = copy.deepcopy(original)

# 修改深拷贝的嵌套对象不会影响原对象
deep_copy[2][0] = 999
print(original)  # [1, 2, [3, 4]]  ✅ 原对象不变！
print(deep_copy)  # [1, 2, [999, 4]]
```

### 3. 特殊情况
#### **3.1  不可变对象 ( int, str, tuple )**

浅拷贝和深拷贝**没有区别**，因为它们本身不可变，Python 会直接复用原对象

```python
a = (1, 2, 3)
b = copy.copy(a)      # 仍然是原元组
c = copy.deepcopy(a)  # 仍然是原元组
print(b is a)  # True
print(c is a)  # True
```

## 线程，进程和携程，有什么区别，都用哪些优缺点已经应用场景

### **1. 进程（Process）—— 独立厨房**
-   **定义**：一个独立的程序执行单位，**拥有独立的内存空间**（比如开一家分店）。
-   **优点**：
    -   稳定性高，一个进程崩溃不会影响其他进程（一家店着火，其他店照常营业🔥➡️🏪）。
    -   适合**CPU密集型任务**（比如视频渲染、科学计算）。
-   **缺点**：
    -   创建和切换开销大（开新店要租场地、招人，慢！）。
    -   进程间通信复杂（分店之间打电话得用IPC，比如管道、消息队列）。
-   **应用场景**：
    -   浏览器（每个标签页是一个进程，崩溃了不影响其他页面）。
    -   Python 的多进程计算（`multiprocessing` 库）。


### **2. 线程（Thread）—— 餐厅里的多个服务员**

-   **定义**：**进程内的子任务**，共享同一块内存（一家店里的多个服务员共用同一个厨房）。
-   **优点**：
    -   创建和切换速度快（服务员培训一下就能上岗）。
    -   适合**IO密集型任务**（比如网络请求、文件读写）。
-   **缺点**：
    -   线程间共享数据容易冲突（服务员A和B同时抢最后一份牛排🥩→可能送错桌）。
    -   一个线程崩溃可能导致整个进程崩溃（一个服务员打翻油锅，整个厨房停摆💥）。
-   **应用场景**：
    -   Web服务器（每个用户请求用一个线程处理，如Java的Tomcat）。
    -   GUI程序（主线程更新界面，子线程后台计算）。

### **3. 协程（Coroutine）—— 一个服务员兼职多桌**

-   **定义**：**用户态轻量级线程**，由程序员手动调度（服务员在A桌点完菜，立刻去B桌倒水，不用等厨师）。
-   **优点**：
    -   超高并发（一个线程能跑几万协程，像超级服务员）。
    -   几乎没有切换开销（没有系统调用，纯代码控制）。
-   **缺点**：
    -   需要配合异步IO（如果协程卡在同步IO上，整个线程阻塞）。
    -   调试复杂（“服务员”跳来跳去，日志像侦探小说🕵️‍♂️）。
-   **应用场景**：
    -   高并发网络服务（如Python的`asyncio`、Go的`goroutine`）。
    -   爬虫（同时发几百个请求，但只用几个线程）。



## python 生成器和迭代器

在 Python 中, 生成器 (Generator) 和迭代器 (Iterator) 都是用于惰性计算的重要工具, 能高效处理大数据流或无限序列. 它们像“流水线工人”一样, 按需生产数据, 而不是一次性加载所有内容到内存;

### 迭代器 (Iterator)

作用: 
- 迭代器是一个实现了 `__iter__()` 和 `__next__()` 方法的对象.
- 每次调用 `next()` 返回一个值, 直到抛出 `StopIteration` 异常.
- 核心特点: 惰性加载, 适合处理大规模数据


```python
class CountDown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        num = self.current
        self.current -= 1
        return num

# 使用迭代器倒计时
countdown = CountDown(3)
print(next(countdown))  # 3
print(next(countdown))  # 2
print(next(countdown))  # 1
# 再调用 next() 会触发 StopIteration
```

适用场景: 
- 遍历数据库查询结果 (避免一次性加载所有记录).
- 实现自定义的数据流 (如分块读取大文件) 

### 生成器 (Generator) 


作用：
- 生成器是迭代器的语法糖, 用 `yield` 关键字定义.
- 函数执行到 `yield` 时暂停, 下次调用从暂停处继续.
- 核心优势：代码更简洁, 内存效率更高.

```python
# 生成器函数 (带 yield)
def count_down(start):
    while start > 0:
        yield start
        start -= 1

# 使用生成器
for num in count_down(3):
    print(num)  # 输出 3, 2, 1

# 生成器表达式 (类似列表推导, 但惰性)
squares = (x*x for x in range(10))
print(next(squares))  # 0
print(next(squares))  # 1
```

适用场景:

- 处理大规模数据 (如日志文件逐行处理)
```python
def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

for line in read_large_file('huge_log.txt'):
    process(line)  # 逐行处理, 不占内存
```

- 无限序列 (如斐波那契数列)
```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
print(next(fib))  # 0
print(next(fib))  # 1
print(next(fib))  # 1
print(next(fib))  # 2
```




## 秒杀系统设计

请你设计一套秒杀系统, 要求是在 15:00 准时开始秒杀活动, 并且单次活动的商品放量是 100 个, 需要考虑并发性和商品不得超发, 另外, 如果在一定时间之内, 没有支付的订单, 需要回收, 商品也会重新入库;

### 一、关键点设计

1. 高并发请求冲击	秒杀瞬间可能百万级请求, 需限流、削峰、异步处理
2. 库存一致性	防止超卖, 必须使用原子操作或分布式锁
3. 防止刷单/机器人	 前端 + 后端多重校验（验证码、限流、用户行为）
4. 订单状态与库存联动	未支付订单需自动释放库存
5. 高可用架构	服务无单点故障, 支持横向扩展
6. 削峰填谷	  使用消息队列异步处理下单请求
7. 缓存设计	   Redis 缓存库存、用户限购、秒杀开关
8. 前端优化	  防重复提交、倒计时、静态资源 CDN 加速
9. 支付超时处理	  定时任务或延迟队列回收库存
10. 可观测性	  日志、监控、链路追踪

### 二、系统整体架构设计

```python
                   +------------------+
                   |   CDN + Vue SPA  |
                   +--------+---------+
                            |
                            v
               +-----------------------+
               |   API Gateway (Nginx) |
               |   - 限流              |
               |   - 路由              |
               +-----------+-----------+
                           |
                           v
           +-------------------------------+
           |     FastAPI 集群 (K8s)        |
           |     - 秒杀接口                |
           |     - 订单创建                |
           |     - 查询订单状态            |
           +-------------------------------+
                           |
         +-----------------+------------------+
         |                                    |
         v                                    v
+------------------+               +---------------------+
|    Redis Cluster   |               |   RabbitMQ / Kafka  |
| - 库存扣减 (Lua)   |               | 异步下单队列         |
| - 用户限购标记     |               | 解耦下单与支付       |
| - 秒杀开关         |               +----------+----------+
+------------------+                          |
                                               v
                                 +---------------------------+
                                 |    订单服务 (Order Worker) |
                                 | - 创建订单                |
                                 | - 检查用户限购            |
                                 | - 调用支付                |
                                 +-------------+-------------+
                                               |
                                               v
                                  +--------------------------+
                                  |   MySQL Cluster (主从)    |
                                  | - 订单表、库存表          |
                                  +--------------------------+

                                               |
                                               v
                                  +--------------------------+
                                  |   定时任务 / 延迟队列      |
                                  | - 30分钟未支付订单回收     |
                                  +--------------------------+
```


### 三、后端接口设计(FastApi + Redis + RabbitMQ)

- 1. 核心接口设计
- 1.1 查询秒杀状态

```python
@app.get("/seckill/status")
async def get_seckill_status(redis: Redis = Depends(get_redis)):
    start_time = datetime(2025, 4, 5, 15, 0)  # 示例时间
    now = datetime.now()
    stock = await redis.get("seckill:stock")
    return {
        "start_time": start_time,
        "current_time": now,
        "status": "not_started" if now < start_time else "ended" if int(stock) <= 0 else "active",
        "remaining": int(stock or 0)
    }
```

- 1.2 秒杀下单接口

```python
@app.post("/seckill/order")
async def create_seckill_order(
    request: Request,
    user_id: str = Body(...),
    redis: Redis = Depends(get_redis),
    channel: Channel = Depends(get_rabbitmq_channel)
):
    # 1. 校验时间
    now = datetime.now()
    if now < datetime(2025, 4, 5, 15, 0):
        raise HTTPException(400, "秒杀未开始")
    
    # 2. 检查用户是否已参与过（限购1件）
    if await redis.get(f"seckill:user:{user_id}"):
        raise HTTPException(400, "您已参与过本次秒杀")

    # 3. Redis 原子扣减库存（Lua 脚本）
    lua_script = """
    local stock = redis.call('GET', 'seckill:stock')
    if not stock then
        return 0
    end
    if tonumber(stock) <= 0 then
        return 0
    end
    redis.call('DECR', 'seckill:stock')
    return 1
    """
    result = await redis.eval(lua_script, numkeys=0)
    if result == 0:
        raise HTTPException(400, "秒杀已结束或库存不足")

    # 4. 标记用户已参与
    await redis.set(f"seckill:user:{user_id}", "1", ex=3600*24)  # 24小时有效

    # 5. 发送消息到 RabbitMQ 异步创建订单
    order_data = {
        "user_id": user_id,
        "product_id": "P100",
        "price": 1,
        "order_id": f"SO{int(time.time())}{random.randint(1000,9999)}"
    }
    channel.basic_publish(
        exchange='',
        routing_key='seckill_order_queue',
        body=json.dumps(order_data),
        properties=pika.BasicProperties(delivery_mode=2)  # 持久化
    )

    return {"code": 0, "msg": "抢购成功, 正在创建订单", "order_id": order_data["order_id"]}
```

- 2. 订单 worker(异步处理)

```python
# worker.py
def order_worker():
    def callback(ch, method, properties, body):
        data = json.loads(body)
        # 写入 MySQL 订单表
        with db_session() as session:
            order = Order(**data, status="unpaid", expire_at=datetime.now() + timedelta(minutes=30))
            session.add(order)
            session.commit()
        # TODO: 触发支付通知
        ch.basic_ack(delivery_tag=method.delivery_tag)
    
    channel.basic_consume(queue='seckill_order_queue', on_message_callback=callback)
    channel.start_consuming()
```

- 3. 支付超时回收库存 (两种方案)
- 3.1 定时任务
```python
# cron job every 5 minutes
def release_expired_orders():
    expired_orders = session.query(Order).filter(
        Order.status == "unpaid",
        Order.expire_at < datetime.now()
    ).all()

    for order in expired_orders:
        # 回收库存
        redis.incr("seckill:stock")
        # 标记用户可再次参与（可选）
        redis.delete(f"seckill:user:{order.user_id}")
        order.status = "expired"
    session.commit()
```

- 3.2 延迟队列

- 使用 RabbitMQ + TTL + Dead Letter Queue 或 Redis ZSet + 定时扫描
- 更实时, 延迟低


### 四、客户端设计

1. 静态资源 CDN 加速	  所有 JS/CSS/图片走 CDN, 减少服务器压力
2. 倒计时组件	          显示距离 15:00 的时间, 使用服务端时间校准
3. 按钮防抖/禁用	      秒杀开始前禁用按钮, 点击后立即置灰
4. 弹窗提示	              抢购成功/失败/库存不足
5. 轮询订单状态	          抢购成功后, 轮询订单是否支付成功
6. 不直接跳转支付	      先抢资格, 再引导支付（异步）
7. 验证码机制（可选）	  秒杀开始前弹出滑动验证码, 防机器人

### 五、防止超卖核心保障

- Redis 原子操作: 使用 Lua 脚本扣减库存, 保证原子性
- 库存预热: 秒杀前将库存加载到 Redis
- 缓存 + 数据库双写一致性: 最终一致, Redis 为主
- 异步下单: 避免数据库直接承受高并发写









